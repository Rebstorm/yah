{"ast":null,"code":"import { ɵɵdefineInjectable, Injectable, InjectionToken, ɵɵinject, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { ReplaySubject, fromEvent, race, throwError, of, Observable, asyncScheduler, from } from 'rxjs';\nimport { mergeMap, map, first, mapTo, takeWhile, tap, observeOn, catchError } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nlet JSONValidator = /*#__PURE__*/(() => {\n  class JSONValidator {\n    /**\n     * Validate a JSON data against a Jsubset of the JSON Schema standard.\n     * Types are enforced to validate everything: each schema must\n     * @param data JSON data to validate\n     * @param schema Subset of JSON Schema. Must have a `type`.\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n     */\n    validate(data, schema) {\n      switch (schema.type) {\n        case 'string':\n          return this.validateString(data, schema);\n\n        case 'number':\n        case 'integer':\n          return this.validateNumber(data, schema);\n\n        case 'boolean':\n          return this.validateBoolean(data, schema);\n\n        case 'array':\n          return this.validateArray(data, schema);\n\n        case 'object':\n          return this.validateObject(data, schema);\n      }\n    }\n    /**\n     * Validate a string\n     * @param data Data to validate\n     * @param schema Schema describing the string\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n\n\n    validateString(data, schema) {\n      if (typeof data !== 'string') {\n        return false;\n      }\n\n      if (!this.validateConst(data, schema)) {\n        return false;\n      }\n\n      if (!this.validateEnum(data, schema)) {\n        return false;\n      }\n\n      if (schema.maxLength !== undefined && data.length > schema.maxLength) {\n        return false;\n      }\n\n      if (schema.minLength !== undefined && data.length < schema.minLength) {\n        return false;\n      }\n\n      if (schema.pattern) {\n        let regularExpression = null;\n\n        try {\n          regularExpression = new RegExp(schema.pattern);\n        } catch (_a) {}\n\n        if (regularExpression && !regularExpression.test(data)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Validate a number or an integer\n     * @param data Data to validate\n     * @param schema Schema describing the number or integer\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n\n\n    validateNumber(data, schema) {\n      if (typeof data !== 'number') {\n        return false;\n      }\n\n      if (schema.type === 'integer' && !Number.isInteger(data)) {\n        return false;\n      }\n\n      if (!this.validateConst(data, schema)) {\n        return false;\n      }\n\n      if (!this.validateEnum(data, schema)) {\n        return false;\n      }\n      /* Test is done this way to not divide by 0 */\n\n\n      if (schema.multipleOf && !Number.isInteger(data / schema.multipleOf)) {\n        return false;\n      }\n\n      if (schema.maximum !== undefined && data > schema.maximum) {\n        return false;\n      }\n\n      if (schema.exclusiveMaximum !== undefined && data >= schema.exclusiveMaximum) {\n        return false;\n      }\n\n      if (schema.minimum !== undefined && data < schema.minimum) {\n        return false;\n      }\n\n      if (schema.exclusiveMinimum !== undefined && data <= schema.exclusiveMinimum) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Validate a boolean\n     * @param data Data to validate\n     * @param schema Schema describing the boolean\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n\n\n    validateBoolean(data, schema) {\n      if (typeof data !== 'boolean') {\n        return false;\n      }\n\n      if (!this.validateConst(data, schema)) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Validate an array\n     * @param data Data to validate\n     * @param schema Schema describing the array\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n\n\n    validateArray(data, schema) {\n      if (!Array.isArray(data)) {\n        return false;\n      }\n\n      if (schema.maxItems !== undefined && data.length > schema.maxItems) {\n        return false;\n      }\n\n      if (schema.minItems !== undefined && data.length < schema.minItems) {\n        return false;\n      }\n\n      if (schema.uniqueItems) {\n        /* Create a set to eliminate values with multiple occurences */\n        const dataSet = new Set(data);\n\n        if (data.length !== dataSet.size) {\n          return false;\n        }\n      }\n      /* Specific test for tuples */\n\n\n      if (Array.isArray(schema.items)) {\n        return this.validateTuple(data, schema.items);\n      }\n      /* Validate all the values in array */\n\n\n      for (const value of data) {\n        // TODO: remove when TypeScript 4.1 is available\n        // (currently the narrowed type from `Array.isArray()` is lost on readonly arrays)\n        if (!this.validate(value, schema.items)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Validate a tuple (array with fixed length and multiple types)\n     * @param data Data to validate\n     * @param schemas Schemas describing the tuple\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n\n\n    validateTuple(data, schemas) {\n      /* Tuples have a fixed length */\n      if (data.length !== schemas.length) {\n        return false;\n      }\n\n      for (let i = 0; i < schemas.length; i += 1) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (!this.validate(data[i], schemas[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Validate an object\n     * @param data Data to validate\n     * @param schema JSON schema describing the object\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n\n\n    validateObject(data, schema) {\n      /* Check the type and if not `null` as `null` also have the type `object` in old browsers */\n      if (typeof data !== 'object' || data === null) {\n        return false;\n      }\n      /* Check if the object doesn't have more properties than expected\n       * Equivalent of `additionalProperties: false`\n       */\n\n\n      if (Object.keys(schema.properties).length < Object.keys(data).length) {\n        return false;\n      }\n      /* Validate required properties */\n\n\n      if (schema.required) {\n        for (const requiredProp of schema.required) {\n          if (!Object.prototype.hasOwnProperty.call(data, requiredProp)) {\n            return false;\n          }\n        }\n      }\n      /* Recursively validate all properties */\n\n\n      for (const property in schema.properties) {\n        /* Filter to keep only real properties (no internal JS stuff) and check if the data has the property too */\n        if (Object.prototype.hasOwnProperty.call(schema.properties, property) && Object.prototype.hasOwnProperty.call(data, property)) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          if (!this.validate(data[property], schema.properties[property])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Validate a constant\n     * @param data Data ta validate\n     * @param schema JSON schema describing the constant\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n\n\n    validateConst(data, schema) {\n      if (!schema.const) {\n        return true;\n      }\n\n      return data === schema.const;\n    }\n    /**\n     * Validate an enum\n     * @param data Data ta validate\n     * @param schema JSON schema describing the enum\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n\n\n    validateEnum(data, schema) {\n      if (!schema.enum) {\n        return true;\n      }\n      /* Cast as the data can be of multiple types, and so TypeScript is lost */\n\n\n      return schema.enum.includes(data);\n    }\n\n  }\n\n  JSONValidator.ɵfac = function JSONValidator_Factory(t) {\n    return new (t || JSONValidator)();\n  };\n\n  JSONValidator.ɵprov = ɵɵdefineInjectable({\n    factory: function JSONValidator_Factory() {\n      return new JSONValidator();\n    },\n    token: JSONValidator,\n    providedIn: \"root\"\n  });\n  return JSONValidator;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Token to provide a prefix to `localStorage` keys.\n */\n\n\nconst LS_PREFIX = new InjectionToken('localStoragePrefix', {\n  providedIn: 'root',\n  factory: () => ''\n});\n/**\n * Default name used for `indexedDB` database.\n */\n\nconst DEFAULT_IDB_DB_NAME = 'ngStorage';\n/**\n * Token to provide `indexedDB` database name.\n */\n\nconst IDB_DB_NAME = new InjectionToken('localStorageIDBDBName', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_DB_NAME\n});\n/**\n * Default version used for `indexedDB` database.\n */\n\nconst DEFAULT_IDB_DB_VERSION = 1;\n/**\n * Token to provide `indexedDB` database version.\n * Must be an unsigned **integer**.\n */\n\nconst IDB_DB_VERSION = new InjectionToken('localStorageIDBDBVersion', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_DB_VERSION\n});\n/**\n * Default name used for `indexedDB` object store.\n */\n\nconst DEFAULT_IDB_STORE_NAME = 'localStorage';\n/**\n * Token to provide `indexedDB` store name.\n * For backward compatibility, the default can't be set now, `IndexedDBDatabase` will do it at runtime.\n */\n\nconst IDB_STORE_NAME = new InjectionToken('localStorageIDBStoreName', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_STORE_NAME\n});\n/**\n * Default value for interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n */\n\nconst DEFAULT_IDB_NO_WRAP = true;\n/**\n * Token to allow interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n * Defaults to `true`. Change to `false` for backward compatiblity in existing applications.\n * **DO NOT CHANGE THIS BEHAVIOR ONCE IN PRODUCTION**, as it would break with existing data.\n */\n\nconst IDB_NO_WRAP = new InjectionToken('localStorageIDBWrap', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_NO_WRAP\n});\n/**\n * Exception message when `indexedDB` is not working\n */\n\nconst IDB_BROKEN_ERROR = 'indexedDB is not working';\n/**\n * Exception raised when `indexedDB` is not working\n */\n\nclass IDBBrokenError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = IDB_BROKEN_ERROR;\n  }\n\n}\n/**\n * Exception message when a value can't be serialized for `localStorage`\n */\n\n\nconst SERIALIZATION_ERROR = `The storage is currently localStorage,\nwhere data must be serialized, and the provided data can't be serialized.`;\n/**\n * Exception raised when a value can't be serialized for `localStorage`\n */\n\nclass SerializationError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = SERIALIZATION_ERROR;\n  }\n\n}\n\nlet IndexedDBDatabase = /*#__PURE__*/(() => {\n  class IndexedDBDatabase {\n    /**\n     * Constructor params are provided by Angular (but can also be passed manually in tests)\n     * @param dbName `indexedDB` database name\n     * @param storeName `indexedDB` store name\n     * @param dbVersion `indexedDB` database version\n     * @param noWrap Flag to not wrap `indexedDB` values for interoperability or to wrap for backward compatibility\n     */\n    constructor(dbName = DEFAULT_IDB_DB_NAME, storeName = DEFAULT_IDB_STORE_NAME, dbVersion = DEFAULT_IDB_DB_VERSION, noWrap = DEFAULT_IDB_NO_WRAP) {\n      /**\n       * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection\n       * even after the connection success event happened\n       */\n      this.database = new ReplaySubject(1);\n      /**\n       * Index used when wrapping value. *For backward compatibility only.*\n       */\n\n      this.wrapIndex = 'value';\n      this.dbName = dbName;\n      this.storeName = storeName;\n      this.dbVersion = dbVersion;\n      this.noWrap = noWrap;\n      /* Connect to `indexedDB`, with prefix if provided by the user */\n\n      this.connect();\n    }\n    /**\n     * Information about `indexedDB` connection. *Only useful for interoperability.*\n     * @returns `indexedDB` database name, store name and database version\n     */\n\n\n    get backingStore() {\n      return {\n        database: this.dbName,\n        store: this.storeName,\n        version: this.dbVersion\n      };\n    }\n    /**\n     * Number of items in our `indexedDB` database and object store\n     */\n\n\n    get size() {\n      /* Open a transaction in read-only mode */\n      return this.transaction('readonly').pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Request to know the number of items */\n\n        const request = store.count();\n        /* Return the result */\n\n        return events.pipe(map(() => request.result));\n      }),\n      /* The observable will complete after the first value */\n      first());\n    }\n    /**\n     * Gets an item value in our `indexedDB` store\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`\n     */\n\n\n    get(key) {\n      /* Open a transaction in read-only mode */\n      return this.transaction('readonly').pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Request the value with the key provided by the user */\n\n        const request = store.get(key);\n        /* Listen events and return the result */\n\n        return events.pipe(map(() => {\n          if (request.result !== undefined && request.result !== null) {\n            /* Prior to v8, the value was wrapped in an `{ value: ...}` object */\n            if (!this.noWrap && typeof request.result === 'object' && this.wrapIndex in request.result && // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            request.result[this.wrapIndex] !== undefined && request.result[this.wrapIndex] !== null) {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n              return request.result[this.wrapIndex];\n            } else {\n              /* Cast to the wanted type */\n              return request.result;\n            }\n          }\n          /* Return `undefined` if the value is empty */\n\n\n          return undefined;\n        }));\n      }),\n      /* The observable will complete after the first value */\n      first());\n    }\n    /**\n     * Sets an item in our `indexedDB` store\n     * @param key The item's key\n     * @param data The item's value\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n\n\n    set(key, data) {\n      /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */\n      if (data === undefined) {\n        return this.delete(key);\n      }\n      /* Open a transaction in write mode */\n\n\n      return this.transaction('readwrite').pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Prior to v8, data was wrapped in a `{ value: ... }` object */\n\n        const dataToStore = this.noWrap ? data : {\n          [this.wrapIndex]: data\n        };\n        /* Add if the item is not existing yet, or update otherwise */\n\n        store.put(dataToStore, key);\n        /* Listen to events and return `undefined` as no value is expected */\n\n        return events.pipe(mapTo(undefined));\n      }),\n      /* The observable will complete after the first value */\n      first());\n    }\n    /**\n     * Deletes an item in our `indexedDB` store\n     * @param key The item's key\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n\n\n    delete(key) {\n      /* Open a transaction in write mode */\n      return this.transaction('readwrite').pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Delete the item in store */\n\n        store.delete(key);\n        /* Listen to events and return `undefined` as no data is expected here */\n\n        return events.pipe(mapTo(undefined));\n      }),\n      /* The observable will complete after the first value */\n      first());\n    }\n    /**\n     * Deletes all items from our `indexedDB` objet store\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n\n\n    clear() {\n      /* Open a transaction in write mode */\n      return this.transaction('readwrite').pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Delete all items in object store */\n\n        store.clear();\n        /* Listen to events and return `undefined` as no data is expected here */\n\n        return events.pipe(mapTo(undefined));\n      }),\n      /* The observable will complete */\n      first());\n    }\n    /**\n     * Get all the keys in our `indexedDB` store\n     * @returns An RxJS `Observable` iterating on each key\n     */\n\n\n    keys() {\n      /* Open a transaction in read-only mode */\n      return this.transaction('readonly').pipe(\n      /* `first()` is used as the final operator in other methods to complete the `Observable`\n       * (as it all starts from a `ReplaySubject` which never ends),\n       * but as this method is iterating over multiple values, `first()` **must** be used here */\n      first(), mergeMap(transactionData => {\n        const {\n          store\n        } = transactionData;\n        /* Open a cursor on the store\n         * `.openKeyCursor()` is better for performance, but only available in indexedDB v2 (missing in IE)\n         * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */\n\n        const request = 'openKeyCursor' in store ? store.openKeyCursor() : store.openCursor();\n        /* Listen to success event */\n\n        const success$ = fromEvent(request, 'success').pipe(\n        /* Stop the `Observable` when the cursor is `null` */\n        takeWhile(() => request.result !== null),\n        /* This lib only allows string keys, but user could have added other types of keys from outside\n         * It's OK to cast as the cursor as been tested in the previous operator */\n        map(() => request.result.key.toString()),\n        /* Iterate on the cursor */\n        tap(() => {\n          request.result.continue();\n        }));\n        /* Listen to error event and if so, throw an error */\n\n        const error$ = this.listenError(request);\n        /* Choose the first event to occur */\n\n        return race([success$, error$]);\n      }));\n    }\n    /**\n     * Check if a key exists in our `indexedDB` store\n     * @returns An RxJS `Observable` telling if the key exists or not\n     */\n\n\n    has(key) {\n      /* Open a transaction in read-only mode */\n      return this.transaction('readonly').pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Check if the key exists in the store\n         * `getKey()` is better but only available in `indexedDB` v2 (Chrome >= 58, missing in IE/Edge Legacy).\n         * In older browsers, the value is checked instead, but it could lead to an exception\n         * if `undefined` was stored outside of this lib (e.g. directly with the native `indexedDB` API).\n         * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69\n         */\n\n        const request = 'getKey' in store ? store.getKey(key) : store.get(key);\n        /* Listen to events and return `true` or `false` */\n\n        return events.pipe(map(() => request.result !== undefined ? true : false));\n      }),\n      /* The observable will complete */\n      first());\n    }\n    /**\n     * Connects to `indexedDB` and creates the object store on first time\n     */\n\n\n    connect() {\n      let request;\n      /* Connect to `indexedDB`\n       * Will fail in Safari cross-origin iframes\n       * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */\n\n      try {\n        /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */\n        request = indexedDB.open(this.dbName, this.dbVersion);\n      } catch (_a) {\n        this.database.error(new IDBBrokenError());\n        return;\n      }\n      /* Create store on first connection */\n\n\n      this.createStore(request);\n      /* Listen to success and error events */\n\n      const success$ = fromEvent(request, 'success');\n      const error$ = this.listenError(request);\n      /* Choose the first to occur */\n\n      race([success$, error$])\n      /* The observable will complete */\n      .pipe(first()).subscribe({\n        next: () => {\n          /* Register the database connection in the `ReplaySubject` for further access */\n          this.database.next(request.result);\n        },\n        error: () => {\n          /* Firefox private mode issue: fallback storage if IndexedDb connection is failing\n          * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n          * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */\n          this.database.error(new IDBBrokenError());\n        }\n      });\n    }\n    /**\n     * Create store on first use of `indexedDB`\n     * @param request `indexedDB` database opening request\n     */\n\n\n    createStore(request) {\n      /* Listen to the event fired on first connection */\n      fromEvent(request, 'upgradeneeded')\n      /* The observable will complete */\n      .pipe(first()).subscribe({\n        next: () => {\n          /* Check if the store already exists, to avoid error */\n          if (!request.result.objectStoreNames.contains(this.storeName)) {\n            /* Create the object store */\n            request.result.createObjectStore(this.storeName);\n          }\n        }\n      });\n    }\n    /**\n     * Open an `indexedDB` transaction and get our store\n     * @param mode `readonly` or `readwrite`\n     * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`\n     */\n\n\n    transaction(mode) {\n      /* From the `indexedDB` connection, open a transaction and get the store */\n      return this.database.pipe(mergeMap(database => {\n        let transaction;\n\n        try {\n          transaction = database.transaction([this.storeName], mode);\n        } catch (error) {\n          /* The store could have been deleted from outside */\n          return throwError(error);\n        }\n        /* Get the store from the transaction */\n\n\n        const store = transaction.objectStore(this.storeName);\n        /* Listen transaction `complete` and `error` events */\n\n        const events = this.listenTransactionEvents(transaction);\n        return of({\n          store,\n          events\n        });\n      }));\n    }\n    /**\n     * Listen errors on a transaction or request, and throw if trigerred\n     * @param transactionOrRequest `indexedDb` transaction or request to listen\n     * @returns An `Observable` listening to errors\n     */\n\n\n    listenError(transactionOrRequest) {\n      return fromEvent(transactionOrRequest, 'error').pipe(\n      /* Throw on error to be able to catch errors in RxJS way.\n       * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`\n       * if we are on the request and the error is only triggered later by the transaction */\n      mergeMap(event => throwError(event.target.error)));\n    }\n    /**\n     * Listen transaction `complete` and `error` events\n     * @param transaction Transaction to listen\n     * @returns An `Observable` listening to transaction `complete` and `error` events\n     */\n\n\n    listenTransactionEvents(transaction) {\n      /* Listen to the `complete` event */\n      const complete$ = fromEvent(transaction, 'complete');\n      /* Listen to the `error` event */\n\n      const error$ = this.listenError(transaction);\n      /* Choose the first event to occur */\n\n      return race([complete$, error$]);\n    }\n\n  }\n\n  IndexedDBDatabase.ɵfac = function IndexedDBDatabase_Factory(t) {\n    return new (t || IndexedDBDatabase)(ɵngcc0.ɵɵinject(IDB_DB_NAME), ɵngcc0.ɵɵinject(IDB_STORE_NAME), ɵngcc0.ɵɵinject(IDB_DB_VERSION), ɵngcc0.ɵɵinject(IDB_NO_WRAP));\n  };\n\n  IndexedDBDatabase.ɵprov = ɵɵdefineInjectable({\n    factory: function IndexedDBDatabase_Factory() {\n      return new IndexedDBDatabase(ɵɵinject(IDB_DB_NAME), ɵɵinject(IDB_STORE_NAME), ɵɵinject(IDB_DB_VERSION), ɵɵinject(IDB_NO_WRAP));\n    },\n    token: IndexedDBDatabase,\n    providedIn: \"root\"\n  });\n  return IndexedDBDatabase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LocalStorageDatabase = /*#__PURE__*/(() => {\n  class LocalStorageDatabase {\n    /**\n     * Constructor params are provided by Angular (but can also be passed manually in tests)\n     * @param prefix Prefix option to avoid collision for multiple apps on the same subdomain or for interoperability\n     */\n    constructor(prefix = '') {\n      /* Prefix if asked, or no prefix otherwise */\n      this.prefix = prefix || '';\n    }\n    /**\n     * Number of items in `localStorage`\n     */\n\n\n    get size() {\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(localStorage.length);\n    }\n    /**\n     * Gets an item value in `localStorage`\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n     */\n\n\n    get(key) {\n      /* Get raw data */\n      const unparsedData = localStorage.getItem(this.prefixKey(key));\n      let parsedData;\n      /* No need to parse if data is `null` or `undefined` */\n\n      if (unparsedData !== undefined && unparsedData !== null) {\n        /* Try to parse */\n        try {\n          parsedData = JSON.parse(unparsedData);\n        } catch (error) {\n          return throwError(error);\n        }\n      }\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n\n      return of(parsedData);\n    }\n    /**\n     * Store an item in `localStorage`\n     * @param key The item's key\n     * @param data The item's value\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n\n\n    set(key, data) {\n      let serializedData = null;\n      /* Check if data can be serialized */\n\n      const dataPrototype = Object.getPrototypeOf(data);\n\n      if (typeof data === 'object' && data !== null && !Array.isArray(data) && !(dataPrototype === Object.prototype || dataPrototype === null)) {\n        return throwError(new SerializationError());\n      }\n      /* Try to stringify (can fail on circular references) */\n\n\n      try {\n        serializedData = JSON.stringify(data);\n      } catch (error) {\n        return throwError(error);\n      }\n      /* Can fail if storage quota is exceeded */\n\n\n      try {\n        localStorage.setItem(this.prefixKey(key), serializedData);\n      } catch (error) {\n        return throwError(error);\n      }\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n\n      return of(undefined);\n    }\n    /**\n     * Deletes an item in `localStorage`\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n\n\n    delete(key) {\n      localStorage.removeItem(this.prefixKey(key));\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n      return of(undefined);\n    }\n    /**\n     * Deletes all items in `localStorage`\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n\n\n    clear() {\n      localStorage.clear();\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n      return of(undefined);\n    }\n    /**\n     * Get all keys in `localStorage`\n     * Note the order of the keys may be inconsistent in Firefox\n     * @returns A RxJS `Observable` iterating on keys\n     */\n\n\n    keys() {\n      /* Create an `Observable` from keys */\n      return new Observable(subscriber => {\n        /* Iteretate over all the indexes */\n        for (let index = 0; index < localStorage.length; index += 1) {\n          /* Cast as we are sure in this case the key is not `null` */\n          subscriber.next(this.getUnprefixedKey(index));\n        }\n\n        subscriber.complete();\n      }).pipe(\n      /* Required to work like other databases which are asynchronous */\n      observeOn(asyncScheduler));\n    }\n    /**\n     * Check if a key exists in `localStorage`\n     * @param key The item's key\n     * @returns A RxJS `Observable` telling if the key exists or not\n     */\n\n\n    has(key) {\n      /* Itérate over all indexes in storage */\n      for (let index = 0; index < localStorage.length; index += 1) {\n        if (key === this.getUnprefixedKey(index)) {\n          /* Wrap in a RxJS `Observable` to be consistent with other storages */\n          return of(true);\n        }\n      }\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n\n      return of(false);\n    }\n    /**\n     * Get an unprefixed key\n     * @param index Index of the key\n     * @returns The unprefixed key name if exists, `null` otherwise\n     */\n\n\n    getUnprefixedKey(index) {\n      /* Get the key in storage: may have a prefix */\n      const prefixedKey = localStorage.key(index);\n\n      if (prefixedKey !== null) {\n        /* If no prefix, the key is already good, otherwrite strip the prefix */\n        return !this.prefix ? prefixedKey : prefixedKey.substr(this.prefix.length);\n      }\n\n      return null;\n    }\n    /**\n     * Add the prefix to a key\n     * @param key The key name\n     * @returns The prefixed key name\n     */\n\n\n    prefixKey(key) {\n      return `${this.prefix}${key}`;\n    }\n\n  }\n\n  LocalStorageDatabase.ɵfac = function LocalStorageDatabase_Factory(t) {\n    return new (t || LocalStorageDatabase)(ɵngcc0.ɵɵinject(LS_PREFIX));\n  };\n\n  LocalStorageDatabase.ɵprov = ɵɵdefineInjectable({\n    factory: function LocalStorageDatabase_Factory() {\n      return new LocalStorageDatabase(ɵɵinject(LS_PREFIX));\n    },\n    token: LocalStorageDatabase,\n    providedIn: \"root\"\n  });\n  return LocalStorageDatabase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MemoryDatabase = /*#__PURE__*/(() => {\n  class MemoryDatabase {\n    constructor() {\n      /**\n       * Memory storage\n       */\n      this.memoryStorage = new Map();\n    }\n    /**\n     * Number of items in memory\n     */\n\n\n    get size() {\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(this.memoryStorage.size);\n    }\n    /**\n     * Gets an item value in memory\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n     */\n\n\n    get(key) {\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(this.memoryStorage.get(key));\n    }\n    /**\n     * Sets an item in memory\n     * @param key The item's key\n     * @param data The item's value\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n\n\n    set(key, data) {\n      this.memoryStorage.set(key, data);\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n      return of(undefined);\n    }\n    /**\n     * Deletes an item in memory\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n\n\n    delete(key) {\n      this.memoryStorage.delete(key);\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n      return of(undefined);\n    }\n    /**\n     * Deletes all items in memory\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n\n\n    clear() {\n      this.memoryStorage.clear();\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n\n      return of(undefined);\n    }\n    /**\n     * Get all keys in memory\n     * @returns A RxJS `Observable` iterating on keys\n     */\n\n\n    keys() {\n      /* Create an `Observable` from keys */\n      return from(this.memoryStorage.keys());\n    }\n    /**\n     * Check if a key exists in memory\n     * @param key Key name\n     * @returns a RxJS `Observable` telling if the key exists or not\n     */\n\n\n    has(key) {\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(this.memoryStorage.has(key));\n    }\n\n  }\n\n  MemoryDatabase.ɵfac = function MemoryDatabase_Factory(t) {\n    return new (t || MemoryDatabase)();\n  };\n\n  MemoryDatabase.ɵprov = ɵɵdefineInjectable({\n    factory: function MemoryDatabase_Factory() {\n      return new MemoryDatabase();\n    },\n    token: MemoryDatabase,\n    providedIn: \"root\"\n  });\n  return MemoryDatabase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Factory to create a storage according to browser support\n * @param platformId Context about the platform (`browser`, `server`...)\n * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain\n * @param IDBDBName `indexedDB` database name\n * @param IDBstoreName `indexedDB` storeName name\n * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/BROWSERS_SUPPORT.md}\n */\n\n\nfunction localDatabaseFactory(platformId, LSPrefix, IDBDBName, IDBStoreName, IDBDBVersion, IDBNoWrap) {\n  /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n   * just trying to check `indexedDB` or `localStorage` variables causes a security exception.\n   * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n   */\n  try {\n    // Do not explicit `window` here, as the global object is not the same in web workers\n    if (isPlatformBrowser(platformId) && indexedDB !== undefined && indexedDB !== null && 'open' in indexedDB) {\n      /* Check:\n      * - if we are in a browser context (issue: server-side rendering)\n      * - it could exist but be `undefined` or `null` (issue: IE private mode)\n      * - it could exists but not having a working API\n      * Will be the case for:\n      * - All other browsers in normal mode\n      * - Chromium / Safari private mode, but in this case, data will be swiped when the user leaves the app */\n      return new IndexedDBDatabase(IDBDBName, IDBStoreName, IDBDBVersion, IDBNoWrap);\n    } else if (isPlatformBrowser(platformId) && localStorage !== undefined && localStorage !== null && 'getItem' in localStorage) {\n      /* Check:\n      * - if we are in a browser context (issue: server-side rendering)\n      * - if `localStorage` exists (to be sure)\n      * - it could exists but not having a working API\n      * Will be the case for:\n      * - Safari cross-origin iframes, detected later in `IndexedDBDatabase.connect()`\n      * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42}\n      * - IE / Firefox private mode, but in this case, data will be swiped when the user leaves the app\n      * For Firefox, can only be detected later in `IndexedDBDatabase.connect()`\n      * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n      */\n      return new LocalStorageDatabase(LSPrefix);\n    }\n  } catch (_a) {}\n  /* Will be the case for:\n   * - In browsers if storage has been fully disabled (via the \"Block all cookies\" option)\n   * - Server-side rendering\n   * - All other non-browser context\n   */\n\n\n  return new MemoryDatabase();\n}\n\nlet LocalDatabase = /*#__PURE__*/(() => {\n  class LocalDatabase {}\n\n  LocalDatabase.ɵfac = function LocalDatabase_Factory(t) {\n    return new (t || LocalDatabase)();\n  };\n\n  LocalDatabase.ɵprov = ɵɵdefineInjectable({\n    factory: function LocalDatabase_Factory() {\n      return localDatabaseFactory(ɵɵinject(PLATFORM_ID), ɵɵinject(LS_PREFIX), ɵɵinject(IDB_DB_NAME), ɵɵinject(IDB_STORE_NAME), ɵɵinject(IDB_DB_VERSION), ɵɵinject(IDB_NO_WRAP));\n    },\n    token: LocalDatabase,\n    providedIn: \"root\"\n  });\n  return LocalDatabase;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Exception message when a value is not valid against the JSON schema\n */\n\n\nconst VALIDATION_ERROR = `Data stored is not valid against the provided JSON schema.\nCheck your JSON schema, otherwise it means data has been corrupted.`;\n/**\n * Exception raised when a value is not valid against the JSON schema\n */\n\nclass ValidationError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = VALIDATION_ERROR;\n  }\n\n}\n\nlet StorageMap = /*#__PURE__*/(() => {\n  class StorageMap {\n    /**\n     * Constructor params are provided by Angular (but can also be passed manually in tests)\n     * @param database Storage to use\n     * @param jsonValidator Validator service\n     * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability\n     */\n    constructor(database, jsonValidator = new JSONValidator(), LSPrefix = '') {\n      this.database = database;\n      this.jsonValidator = jsonValidator;\n      this.LSPrefix = LSPrefix;\n      this.notifiers = new Map();\n    }\n    /**\n     * **Number of items** in storage, wrapped in an `Observable`.\n     *\n     * @example\n     * this.storageMap.size.subscribe((size) => {\n     *   console.log(size);\n     * });\n     */\n\n\n    get size() {\n      return this.database.size\n      /* Catch if `indexedDb` is broken */\n      .pipe(this.catchIDBBroken(() => this.database.size));\n    }\n    /**\n     * Tells you which storage engine is used. *Only useful for interoperability.*\n     * Note that due to some browsers issues in some special contexts\n     * (Firefox private mode and Safari cross-origin iframes),\n     * **this information may be wrong at initialization,**\n     * as the storage could fallback from `indexedDB` to `localStorage`\n     * only after a first read or write operation.\n     * @returns Storage engine used\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'indexedDB') {}\n     */\n\n\n    get backingEngine() {\n      if (this.database instanceof IndexedDBDatabase) {\n        return 'indexedDB';\n      } else if (this.database instanceof LocalStorageDatabase) {\n        return 'localStorage';\n      } else if (this.database instanceof MemoryDatabase) {\n        return 'memory';\n      } else {\n        return 'unknown';\n      }\n    }\n    /**\n     * Info about `indexedDB` database. *Only useful for interoperability.*\n     * @returns `indexedDB` database name, store name and database version.\n     * **Values will be empty if the storage is not `indexedDB`,**\n     * **so it should be used after an engine check**.\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'indexedDB') {\n     *   const { database, store, version } = this.storageMap.backingStore;\n     * }\n     */\n\n\n    get backingStore() {\n      return this.database instanceof IndexedDBDatabase ? this.database.backingStore : {\n        database: '',\n        store: '',\n        version: 0\n      };\n    }\n    /**\n     * Info about `localStorage` fallback storage. *Only useful for interoperability.*\n     * @returns `localStorage` prefix.\n     * **Values will be empty if the storage is not `localStorage`,**\n     * **so it should be used after an engine check**.\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'localStorage') {\n     *   const { prefix } = this.storageMap.fallbackBackingStore;\n     * }\n     */\n\n\n    get fallbackBackingStore() {\n      return this.database instanceof LocalStorageDatabase ? {\n        prefix: this.database.prefix\n      } : {\n        prefix: ''\n      };\n    }\n\n    get(key, schema) {\n      /* Get the data in storage */\n      return this.database.get(key).pipe(\n      /* Check if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.get(key)), mergeMap(data => {\n        /* No need to validate if the data is empty */\n        if (data === undefined || data === null) {\n          return of(undefined);\n        } else if (schema) {\n          /* Validate data against a JSON schema if provided */\n          if (!this.jsonValidator.validate(data, schema)) {\n            return throwError(new ValidationError());\n          }\n          /* Data have been checked, so it's OK to cast */\n\n\n          return of(data);\n        }\n        /* Cast to unknown as the data wasn't checked */\n\n\n        return of(data);\n      }));\n    }\n    /**\n     * Set an item in storage.\n     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n     * @param key The item's key\n     * @param data The item's value\n     * @param schema Optional JSON schema to validate the data\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.set('key', 'value').subscribe(() => {});\n     */\n\n\n    set(key, data, schema) {\n      /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,\n       * so removing item instead for all storages to have a consistent API */\n      if (data === undefined || data === null) {\n        return this.delete(key);\n      }\n      /* Validate data against a JSON schema if provided */\n\n\n      if (schema && !this.jsonValidator.validate(data, schema)) {\n        return throwError(new ValidationError());\n      }\n\n      return this.database.set(key, data).pipe(\n      /* Catch if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.set(key, data)),\n      /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n      tap(() => {\n        this.notify(key, data);\n      }));\n    }\n    /**\n     * Delete an item in storage\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.delete('key').subscribe(() => {});\n     */\n\n\n    delete(key) {\n      return this.database.delete(key).pipe(\n      /* Catch if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.delete(key)),\n      /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n      tap(() => {\n        this.notify(key, undefined);\n      }));\n    }\n    /**\n     * Delete all items in storage\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.clear().subscribe(() => {});\n     */\n\n\n    clear() {\n      return this.database.clear().pipe(\n      /* Catch if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.clear()),\n      /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n      tap(() => {\n        for (const key of this.notifiers.keys()) {\n          this.notify(key, undefined);\n        }\n      }));\n    }\n    /**\n     * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:\n     * * if there is no key, the `next` callback will not be invoked,\n     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,\n     * as this `Observable` can emit several values and so will invoke the `next` callback several times.\n     * @returns A list of the keys wrapped in a RxJS `Observable`\n     *\n     * @example\n     * this.storageMap.keys().subscribe({\n     *   next: (key) => { console.log(key); },\n     *   complete: () => { console.log('Done'); },\n     * });\n     */\n\n\n    keys() {\n      return this.database.keys()\n      /* Catch if `indexedDb` is broken */\n      .pipe(this.catchIDBBroken(() => this.database.keys()));\n    }\n    /**\n     * Tells if a key exists in storage\n     * @returns A RxJS `Observable` telling if the key exists\n     *\n     * @example\n     * this.storageMap.has('key').subscribe((hasKey) => {\n     *   if (hasKey) {}\n     * });\n     */\n\n\n    has(key) {\n      return this.database.has(key)\n      /* Catch if `indexedDb` is broken */\n      .pipe(this.catchIDBBroken(() => this.database.has(key)));\n    }\n\n    watch(key, schema) {\n      /* Check if there is already a notifier */\n      if (!this.notifiers.has(key)) {\n        this.notifiers.set(key, new ReplaySubject(1));\n      }\n      /* Non-null assertion is required because TypeScript doesn't narrow `.has()` yet */\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      const notifier = this.notifiers.get(key);\n      /* Get the current item value */\n\n      (schema ? this.get(key, schema) : this.get(key)).subscribe({\n        next: result => notifier.next(result),\n        error: error => notifier.error(error)\n      });\n      /* Only the public API of the `Observable` should be returned */\n\n      return schema ? notifier.asObservable() : notifier.asObservable();\n    }\n    /**\n     * Notify when a value changes\n     * @param key The item's key\n     * @param data The new value\n     */\n\n\n    notify(key, value) {\n      const notifier = this.notifiers.get(key);\n\n      if (notifier) {\n        notifier.next(value);\n      }\n    }\n    /**\n     * RxJS operator to catch if `indexedDB` is broken\n     * @param operationCallback Callback with the operation to redo\n     */\n\n\n    catchIDBBroken(operationCallback) {\n      return catchError(error => {\n        /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */\n        if (error !== undefined && error !== null && typeof error === 'object' && 'message' in error // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        && error.message === IDB_BROKEN_ERROR) {\n          /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n           * just trying to check `localStorage` variable causes a security exception.\n           * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n           */\n          try {\n            if ('getItem' in localStorage) {\n              /* Fallback to `localStorage` if available */\n              this.database = new LocalStorageDatabase(this.LSPrefix);\n            } else {\n              /* Fallback to memory storage otherwise */\n              this.database = new MemoryDatabase();\n            }\n          } catch (_a) {\n            /* Fallback to memory storage otherwise */\n            this.database = new MemoryDatabase();\n          }\n          /* Redo the operation */\n\n\n          return operationCallback();\n        } else {\n          /* Otherwise, rethrow the error */\n          return throwError(error);\n        }\n      });\n    }\n\n  }\n\n  StorageMap.ɵfac = function StorageMap_Factory(t) {\n    return new (t || StorageMap)(ɵngcc0.ɵɵinject(LocalDatabase), ɵngcc0.ɵɵinject(JSONValidator), ɵngcc0.ɵɵinject(LS_PREFIX));\n  };\n\n  StorageMap.ɵprov = ɵɵdefineInjectable({\n    factory: function StorageMap_Factory() {\n      return new StorageMap(ɵɵinject(LocalDatabase), ɵɵinject(JSONValidator), ɵɵinject(LS_PREFIX));\n    },\n    token: StorageMap,\n    providedIn: \"root\"\n  });\n  return StorageMap;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet LocalStorage = /*#__PURE__*/(() => {\n  class LocalStorage {\n    /* Use the `StorageMap` service to avoid code duplication */\n    constructor(storageMap) {\n      this.storageMap = storageMap;\n    }\n    /**\n     * Number of items in storage wrapped in an `Observable`\n     *\n     * @example\n     * this.localStorage.length.subscribe((length) => {\n     *   console.log(length);\n     * });\n     */\n\n\n    get length() {\n      return this.storageMap.size;\n    }\n\n    getItem(key, schema) {\n      if (schema) {\n        /* Backward compatibility with version <= 7 */\n        schema = 'schema' in schema ? schema.schema : schema;\n      }\n\n      return (schema ? this.storageMap.get(key, schema) : this.storageMap.get(key)).pipe(\n      /* Transform `undefined` into `null` to align with `localStorage` API */\n      map(value => value !== undefined ? value : null));\n    }\n    /**\n     * Set an item in storage.\n     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n     * @param key The item's key\n     * @param data The item's value\n     * @param schema Optional JSON schema to validate the data\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.localStorage.set('key', 'value').subscribe(() => {});\n     */\n\n\n    setItem(key, data, schema) {\n      return this.storageMap.set(key, data, schema).pipe(\n      /* Transform `undefined` into `true` for backward compatibility with v7 */\n      mapTo(true));\n    }\n    /**\n     * Delete an item in storage\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.localStorage.delete('key').subscribe(() => {});\n     */\n\n\n    removeItem(key) {\n      return this.storageMap.delete(key).pipe(\n      /* Transform `undefined` into `true` for backward compatibility with v7 */\n      mapTo(true));\n    }\n    /**\n     * Delete all items in storage\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.localStorage.clear().subscribe(() => {});\n     */\n\n\n    clear() {\n      return this.storageMap.clear().pipe(\n      /* Transform `undefined` into `true` for backward compatibility with v7 */\n      mapTo(true));\n    }\n\n  }\n\n  LocalStorage.ɵfac = function LocalStorage_Factory(t) {\n    return new (t || LocalStorage)(ɵngcc0.ɵɵinject(StorageMap));\n  };\n\n  LocalStorage.ɵprov = ɵɵdefineInjectable({\n    factory: function LocalStorage_Factory() {\n      return new LocalStorage(ɵɵinject(StorageMap));\n    },\n    token: LocalStorage,\n    providedIn: \"root\"\n  });\n  return LocalStorage;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * This module does not contain anything, it's only useful to provide options via `.forRoot()`.\n */\n\n\nlet StorageModule = /*#__PURE__*/(() => {\n  class StorageModule {\n    /**\n     * Only useful to provide options, otherwise it does nothing.\n     * **Must be used at initialization, ie. in `AppModule`, and must not be loaded again in another module.**\n     *\n     * @example\n     * NgModule({\n     *   imports: [StorageModule.forRoot({\n     *     LSPrefix: 'custom_',\n     *   })]\n     * })\n     * export class AppModule\n     */\n    static forRoot(config) {\n      return {\n        ngModule: StorageModule,\n        providers: [config.LSPrefix ? {\n          provide: LS_PREFIX,\n          useValue: config.LSPrefix\n        } : [], config.IDBDBName ? {\n          provide: IDB_DB_NAME,\n          useValue: config.IDBDBName\n        } : [], config.IDBStoreName ? {\n          provide: IDB_STORE_NAME,\n          useValue: config.IDBStoreName\n        } : [], config.IDBDBVersion ? {\n          provide: IDB_DB_VERSION,\n          useValue: config.IDBDBVersion\n        } : [], config.IDBNoWrap === false ? {\n          provide: IDB_NO_WRAP,\n          useValue: config.IDBNoWrap\n        } : []]\n      };\n    }\n\n  }\n\n  StorageModule.ɵfac = function StorageModule_Factory(t) {\n    return new (t || StorageModule)();\n  };\n\n  StorageModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: StorageModule\n  });\n  StorageModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return StorageModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of local-storage\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { JSONValidator, LocalDatabase, LocalStorage, SERIALIZATION_ERROR, SerializationError, StorageMap, StorageModule, VALIDATION_ERROR, ValidationError, localDatabaseFactory as ɵa, LS_PREFIX as ɵb, IDB_DB_NAME as ɵc, IDB_DB_VERSION as ɵd, IDB_STORE_NAME as ɵe, IDB_NO_WRAP as ɵf }; //# sourceMappingURL=ngx-pwa-local-storage.js.map","map":null,"metadata":{},"sourceType":"module"}